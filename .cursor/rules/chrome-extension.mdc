---
alwaysApply: true
---
# Chrome 扩展开发规范

## 扩展架构

### 核心组件
Egret Inspector 基于 Chrome 扩展架构，包含以下核心组件：

1. **Background Script**: [src/scripts/background/](mdc:src/scripts/background/)
   - 中央消息路由
   - 端口管理
   - 生命周期管理

2. **Content Script**: [src/scripts/content/](mdc:src/scripts/content/)
   - 页面内容脚本
   - DOM 事件处理
   - 与 Inject Script 通信

3. **Inject Script**: [src/scripts/inject/](mdc:src/scripts/inject/)
   - 注入到页面
   - 与 Egret 引擎交互
   - 调试功能实现

4. **DevTools Panel**: [src/views/devtools/](mdc:src/views/devtools/)
   - 用户界面
   - 调试工具界面
   - 与 Background Script 通信

## 消息通信

### 消息类型定义
参考 [const.ts](mdc:src/scripts/const.ts) 中的消息类型：

```typescript
export enum Msg {
  RequestSupport = "request-support",
  ResponseSupport = "response-support",
  RequstTreeInfo = "request-tree-info",
  ResponseTreeInfo = "response-tree-info",
  RequestNodeInfo = "request-node-info",
  ResponseNodeInfo = "response-node-info",
  RequestSetProperty = "request-set-property",
  ResponseSetProperty = "response-set-property",
  ResponseError = "response-error",
}
```

### 通信流程
1. **DevTools → Inject**: DevTools Panel → Background Script → Content Script → Inject Script
2. **Inject → DevTools**: Inject Script → Content Script → Background Script → DevTools Panel

## 端口管理

### PortMgr 类
参考 [portMgr.ts](mdc:src/scripts/background/portMgr.ts) 的端口管理模式：

```typescript
class PortManager {
  private ports: Map<string, Port> = new Map()
  
  addPort(id: string, port: Port): void {
    this.ports.set(id, port)
  }
  
  removePort(id: string): void {
    this.ports.delete(id)
  }
  
  sendMessage(portId: string, message: Message): void {
    const port = this.ports.get(portId)
    if (port) {
      port.postMessage(message)
    }
  }
}
```

## 生命周期管理

### Background Script 生命周期
```typescript
// 扩展安装时
chrome.runtime.onInstalled.addListener((details) => {
  if (details.reason === 'install') {
    console.log('Extension installed')
  }
})

// 扩展启动时
chrome.runtime.onStartup.addListener(() => {
  console.log('Extension started')
})
```

## 错误处理

### 连接错误处理
```typescript
class ConnectionManager {
  private reconnectAttempts = 0
  private maxReconnectAttempts = 5
  
  async connect(): Promise<void> {
    try {
      await this.establishConnection()
      this.reconnectAttempts = 0
    } catch (error) {
      this.handleConnectionError(error)
    }
  }
  
  private handleConnectionError(error: Error): void {
    console.error('Connection failed:', error)
    
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++
      setTimeout(() => this.connect(), 1000 * this.reconnectAttempts)
    }
  }
}
```

## 最佳实践

1. **消息路由**: 所有消息必须通过 Background Script 路由
2. **错误处理**: 实现完整的错误处理和重试机制
3. **性能优化**: 使用缓存和批处理提高性能
4. **安全验证**: 验证所有消息和来源
5. **权限最小化**: 只请求必要的权限
6. **生命周期管理**: 正确处理扩展的生命周期事件
# Chrome 扩展开发规范

## 扩展架构

### 核心组件
Egret Inspector 基于 Chrome 扩展架构，包含以下核心组件：

1. **Background Script**: [src/scripts/background/](mdc:src/scripts/background/)
   - 中央消息路由
   - 端口管理
   - 生命周期管理

2. **Content Script**: [src/scripts/content/](mdc:src/scripts/content/)
   - 页面内容脚本
   - DOM 事件处理
   - 与 Inject Script 通信

3. **Inject Script**: [src/scripts/inject/](mdc:src/scripts/inject/)
   - 注入到页面
   - 与 Egret 引擎交互
   - 调试功能实现

4. **DevTools Panel**: [src/views/devtools/](mdc:src/views/devtools/)
   - 用户界面
   - 调试工具界面
   - 与 Background Script 通信

## 消息通信

### 消息类型定义
参考 [const.ts](mdc:src/scripts/const.ts) 中的消息类型：

```typescript
export enum Msg {
  RequestSupport = "request-support",
  ResponseSupport = "response-support",
  RequstTreeInfo = "request-tree-info",
  ResponseTreeInfo = "response-tree-info",
  RequestNodeInfo = "request-node-info",
  ResponseNodeInfo = "response-node-info",
  RequestSetProperty = "request-set-property",
  ResponseSetProperty = "response-set-property",
  ResponseError = "response-error",
}
```

### 通信流程
1. **DevTools → Inject**: DevTools Panel → Background Script → Content Script → Inject Script
2. **Inject → DevTools**: Inject Script → Content Script → Background Script → DevTools Panel

## 端口管理

### PortMgr 类
参考 [portMgr.ts](mdc:src/scripts/background/portMgr.ts) 的端口管理模式：

```typescript
class PortManager {
  private ports: Map<string, Port> = new Map()
  
  addPort(id: string, port: Port): void {
    this.ports.set(id, port)
  }
  
  removePort(id: string): void {
    this.ports.delete(id)
  }
  
  sendMessage(portId: string, message: Message): void {
    const port = this.ports.get(portId)
    if (port) {
      port.postMessage(message)
    }
  }
}
```

## 生命周期管理

### Background Script 生命周期
```typescript
// 扩展安装时
chrome.runtime.onInstalled.addListener((details) => {
  if (details.reason === 'install') {
    console.log('Extension installed')
  }
})

// 扩展启动时
chrome.runtime.onStartup.addListener(() => {
  console.log('Extension started')
})
```

## 错误处理

### 连接错误处理
```typescript
class ConnectionManager {
  private reconnectAttempts = 0
  private maxReconnectAttempts = 5
  
  async connect(): Promise<void> {
    try {
      await this.establishConnection()
      this.reconnectAttempts = 0
    } catch (error) {
      this.handleConnectionError(error)
    }
  }
  
  private handleConnectionError(error: Error): void {
    console.error('Connection failed:', error)
    
    if (this.reconnectAttempts < this.maxReconnectAttempts) {
      this.reconnectAttempts++
      setTimeout(() => this.connect(), 1000 * this.reconnectAttempts)
    }
  }
}
```

## 最佳实践

1. **消息路由**: 所有消息必须通过 Background Script 路由
2. **错误处理**: 实现完整的错误处理和重试机制
3. **性能优化**: 使用缓存和批处理提高性能
4. **安全验证**: 验证所有消息和来源
5. **权限最小化**: 只请求必要的权限
6. **生命周期管理**: 正确处理扩展的生命周期事件
